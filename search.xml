<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwnagotchi</title>
      <link href="/2023/10/10/pwnagotchi/"/>
      <url>/2023/10/10/pwnagotchi/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwnagotchi"><a href="#Pwnagotchi" class="headerlink" title="Pwnagotchi"></a>Pwnagotchi</h1><p><a href="https://pwnagotchi.ai/">官网</a><br>这个小东西可耗精力了，不知道为什么老是有问题，或许是我墨水屏买新了？以及进不去MANU mode，可能是驱动？<br>不知道，以后再说吧。</p><hr><h2 id="0x0-买"><a href="#0x0-买" class="headerlink" title="0x0 买"></a>0x0 买</h2><p>需要买的：</p><ul><li><a href="https://www.raspberrypi.com/products/raspberry-pi-zero-w/">Raspberry Pi Zero W</a></li><li>16GB <a href="https://www.westerndigital.com/zh-cn/products/memory-cards/sandisk-extreme-uhs-i-microsd">MicroSD卡</a><br>还要用的：</li><li>MicroSD读卡器</li><li>数据线<br>锦上添花的：</li><li>2.13inch墨水屏，我用了<a href="https://www.waveshare.com/product/raspberry-pi/displays/e-paper/2.13inch-e-paper-hat.htm">微雪的V4</a>，不过底下那个镜像也支持？</li><li><a href="https://www.alibaba.com/product-detail/Ups-Lite-for-Raspberry-pi-Zero_62590553050.html">UPS-Lite 电池&#x2F;不间断电源</a>，这个可以用充电宝代替（拖出来根线，不喜欢）</li><li>GPIO引脚</li><li>3D打印外壳<br>如果不想焊接你可以买Zero WH，引脚焊好的版本</li></ul><h2 id="0x1-焊"><a href="#0x1-焊" class="headerlink" title="0x1 焊"></a>0x1 焊</h2><p>焊GPIO的时候可以先焊两边再焊中间，平衡之后焊起来会很方便</p><p>微雪V3已经有GPIO焊好了，直接插上去就行，记得屏是覆盖住Zero的，不是呈Z状凸出的，插反了的话小心坏掉</p><p>UPS-Lite是弹簧针脚，直接放上去按紧拧好螺丝和螺母就OK了</p><h2 id="0x2-烧"><a href="#0x2-烧" class="headerlink" title="0x2 烧"></a>0x2 烧</h2><p>烧录的时候尝试了<a href="https://github.com/evilsocket/pwnagotchi">原项目</a>的镜像，结果墨水屏没显示，所以总结是这样的：</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>用的<a href="https://github.com/xMasterX/pwnagotchi/releases/tag/v1.5.6">这个镜像</a>（不然墨水屏显示不了，原镜像有一些奇奇怪怪的bug，但是用这个镜像的话MANU mode就用不了了，握手包需要读卡才能用）。</p><h3 id="烧写"><a href="#烧写" class="headerlink" title="烧写"></a>烧写</h3><p>使用<a href="https://www.raspberrypi.com/software/">树莓派烧写工具</a>或者按<a href="https://pwnagotchi.ai/installation/#flashing-an-image">原项目</a>说的用<a href="https://etcher.balena.io/#download-etcher">balenaEtcher</a>都一样，插上电脑就能写。Windows写完之后会弹出是否格式化，这时候忽略就行。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>参照这个，我们需要改一些东西：<br><code>config.toml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">main.name</span> <span class="string">=</span> <span class="string">&quot;pwnagotchi&quot;</span>             <span class="comment"># Your pwnagotchi&#x27;s name</span></span><br><span class="line"><span class="string">main.lang</span> <span class="string">=</span> <span class="string">&quot;en&quot;</span>                     <span class="comment"># Interface language, zh-Hans is not supported</span></span><br><span class="line"><span class="string">main.whitelist</span> <span class="string">=</span> [</span><br><span class="line">  <span class="string">&quot;EXAMPLE_NETWORK&quot;</span>,                 <span class="comment"># The network which pwnagotchi will not deauth, </span></span><br><span class="line">  <span class="string">&quot;ANOTHER_EXAMPLE_NETWORK&quot;</span>,         <span class="comment"># but pwnagotchi will still capture the handshake</span></span><br><span class="line">  <span class="string">&quot;fo:od:ba:be:fo:od&quot;</span>,               <span class="comment"># of every APs. </span></span><br><span class="line">  <span class="string">&quot;fo:od:ba&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="string">main.plugins.grid.enabled</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">main.plugins.grid.report</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">main.plugins.grid.exclude</span> <span class="string">=</span> [</span><br><span class="line">  <span class="string">&quot;YourHomeNetworkHere&quot;</span>              <span class="comment"># The same config as main.whitelist is the </span></span><br><span class="line">]                                    <span class="comment"># simplest.</span></span><br><span class="line"></span><br><span class="line"><span class="string">ui.display.enabled</span> <span class="string">=</span> <span class="literal">true</span>            <span class="comment"># This is the e-Paper screen configuration. </span></span><br><span class="line"><span class="string">ui.display.type</span> <span class="string">=</span> <span class="string">&quot;waveshare_3&quot;</span>      <span class="comment"># Using WaveShare e-Paper V3 (actually V4). </span></span><br><span class="line"><span class="string">ui.display.color</span> <span class="string">=</span> <span class="string">&quot;black&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写完之后要放在bootfs分区的根目录下。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>很简单，把烧好的Micro SD卡放进ZeroW中插电开机即可。</p><h2 id="0x3-走"><a href="#0x3-走" class="headerlink" title="0x3 走"></a>0x3 走</h2><p>正如官网介绍的，</p><blockquote><p><a href="https://twitter.com/pwnagotchi">Pwnagotchi</a> is an <a href="https://hackernoon.com/intuitive-rl-intro-to-advantage-actor-critic-a2c-4ff545978752">A2C</a>-based “AI” powered by <a href="https://www.bettercap.org/">bettercap</a> and running on a <a href="https://www.raspberrypi.org/products/raspberry-pi-zero-w/">Raspberry Pi Zero W</a> that learns from its surrounding WiFi environment in order to maximize the <a href="https://pwnagotchi.ai/intro/#wifi-handshakes-101">crackable WPA key material it captures</a> (either through passive sniffing or by performing deauthentication and association attacks).</p></blockquote><p>这玩意儿是一个吃Wi-Fi握手包的电子宠物，如何拿到更多握手包？那自然是出去走走了。<br>公园里走走，街道旁走走，商场里走走，到处都是握手包，何必担心“饿着”它呢？</p><h1 id="以及……"><a href="#以及……" class="headerlink" title="以及……"></a>以及……</h1><p>我们给这个小东西以“食物”，这个小东西给了我们出去多活动的机会，这对我们何尝不是一种额外的收获呢？</p>]]></content>
      
      
      <categories>
          
          <category> Hacking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hacking </tag>
            
            <tag> Pwn </tag>
            
            <tag> Pwnagotchi </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>于Windows上部署ChatGLM2-6B 以及其WebUI</title>
      <link href="/2023/09/02/%E4%BA%8EWindows%E4%B8%8A%E9%83%A8%E7%BD%B2ChatGLM2-6B%20%E4%BB%A5%E5%8F%8A%E5%85%B6WebUI/"/>
      <url>/2023/09/02/%E4%BA%8EWindows%E4%B8%8A%E9%83%A8%E7%BD%B2ChatGLM2-6B%20%E4%BB%A5%E5%8F%8A%E5%85%B6WebUI/</url>
      
        <content type="html"><![CDATA[<p>寻思要给自己搞一个能上网的GLM2-6B，就在<a href="https://chatglm.cn/blog">GLM官网</a>找有没有友链，正好找到了这么一条：<a href="https://github.com/LemonQu-GIT/ChatGLM-6B-Engineering">ChatGLM-6B-Engineering</a>，于是就打算在本地部署一下（我是比较讨厌语言模型不在本地的那种）。坑有点多，于是用几乎是0基础的方式写了这么一篇教程。<br>本篇文章使用venv来创建虚拟环境，conda创建环境的可以找别人了。</p><hr><h2 id="0x0-拉代码"><a href="#0x0-拉代码" class="headerlink" title="0x0 拉代码"></a>0x0 拉代码</h2><h2 id="到这个工程的仓库拉下代码，解压到一个文件夹。创建一个命令行窗口，然后cd到你的目录。"><a href="#到这个工程的仓库拉下代码，解压到一个文件夹。创建一个命令行窗口，然后cd到你的目录。" class="headerlink" title="到这个工程的仓库拉下代码，解压到一个文件夹。创建一个命令行窗口，然后cd到你的目录。"></a>到这个工程的仓库拉下代码，解压到一个文件夹。<br>创建一个命令行窗口，然后cd到你的目录。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">rem Go to your working dir. </span></span><br><span class="line"><span class="built_in">cd</span> /D D:\<span class="built_in">path</span>\to\your\workspace</span><br></pre></td></tr></table></figure></h2><h2 id="0x1-创建环境"><a href="#0x1-创建环境" class="headerlink" title="0x1 创建环境"></a>0x1 创建环境</h2><h2 id="然后创建python虚拟环境（有些人极度讨厌虚拟环境可以跳过，此处使用venv而不是conda是因为我比较讨厌conda）：确保缓存的盘足够，如果不能的话，就会报pip没有足够的空间安装，你需要这么做：然后再在同一窗口安装执行：pip安装依赖："><a href="#然后创建python虚拟环境（有些人极度讨厌虚拟环境可以跳过，此处使用venv而不是conda是因为我比较讨厌conda）：确保缓存的盘足够，如果不能的话，就会报pip没有足够的空间安装，你需要这么做：然后再在同一窗口安装执行：pip安装依赖：" class="headerlink" title="然后创建python虚拟环境（有些人极度讨厌虚拟环境可以跳过，此处使用venv而不是conda是因为我比较讨厌conda）：确保缓存的盘足够，如果不能的话，就会报pip没有足够的空间安装，你需要这么做：然后再在同一窗口安装执行：pip安装依赖："></a>然后创建python虚拟环境（有些人极度讨厌虚拟环境可以跳过，此处使用venv而不是conda是因为我比较讨厌conda）：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">rem Run python to create venv. </span></span><br><span class="line">python -m venv .\venv</span><br></pre></td></tr></table></figure><br>确保缓存的盘足够，如果不能的话，就会报pip没有足够的空间安装，你需要这么做：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">rem Set the cache dir. </span></span><br><span class="line"><span class="built_in">set</span> TMPDIR=D:\your\cache\<span class="built_in">dir</span></span><br></pre></td></tr></table></figure><br>然后再在同一窗口安装执行：<br>pip安装依赖：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></h2><h2 id="0x2-使用模型搭建GLM层API"><a href="#0x2-使用模型搭建GLM层API" class="headerlink" title="0x2 使用模型搭建GLM层API"></a>0x2 使用模型搭建GLM层API</h2><p>接下来GLM模型就已经基本可以使用了。<br>ChatGLM有量化，可以在稍微性能不足一点的电脑上运行：<br>以下内容摘自<a href="https://github.com/THUDM/ChatGLM-6B#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">ChatGLM-6B的README.md</a>:</p><h3 id="硬件需求"><a href="#硬件需求" class="headerlink" title="硬件需求"></a>硬件需求</h3><table><thead><tr><th><strong>量化等级</strong></th><th><strong>最低 GPU 显存</strong>（推理）</th><th><strong>最低 GPU 显存</strong>（高效参数微调）</th></tr></thead><tbody><tr><td>FP16（无量化）</td><td>13 GB</td><td>14 GB</td></tr><tr><td>INT8</td><td>8 GB</td><td>9 GB</td></tr><tr><td>INT4</td><td>6 GB</td><td>7 GB</td></tr></tbody></table><p>实在不行还可以在CPU上运行，这个稍后会提到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;THUDM/chatglm2-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;THUDM/chatglm2-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>).quantize(<span class="number">4</span>).half().cuda()</span><br></pre></td></tr></table></figure><p>上面的代码中，表示量化的在这里：<code>.quantize(4)</code>，这表示该模型使用INT4量化，同理<code>.quantize(8)</code>就是使用INT8量化。<br>但是使用他的API还需要改一点东西：<br>他的模型使用本地模型，我们把它改成线上模型。<br>改一行代码：<br><code>.\api.py</code><br>更改前：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tokenizer = AutoTokenizer.from_pretrained(&quot;THUDM/chatglm2-6b&quot;, trust_remote_code=True)</span></span><br><span class="line"><span class="comment">#model = AutoModel.from_pretrained(&quot;THUDM/chatglm2-6b&quot;, trust_remote_code=True).quantize(4).half().cuda()</span></span><br><span class="line"><span class="comment">#tokenizer = AutoTokenizer.from_pretrained(r&quot;E:\huggingface\models--THUDM--chatglm-6b\snapshots\a10da4c68b5d616030d3531fc37a13bb44ea814d&quot;, trust_remote_code=True)</span></span><br><span class="line"><span class="comment">#model = AutoModel.from_pretrained(r&quot;E:\huggingface\models--THUDM--chatglm-6b\snapshots\a10da4c68b5d616030d3531fc37a13bb44ea814d&quot;, trust_remote_code=True).quantize(4).half().cuda()</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">r&quot;E:\model\chatglm2-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">r&quot;E:\model\chatglm2-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>).quantize(<span class="number">4</span>).half().cuda()</span><br></pre></td></tr></table></figure><p>更改后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;THUDM/chatglm2-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;THUDM/chatglm2-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>).quantize(<span class="number">4</span>).half().cuda()</span><br><span class="line"><span class="comment">#tokenizer = AutoTokenizer.from_pretrained(r&quot;E:\huggingface\models--THUDM--chatglm-6b\snapshots\a10da4c68b5d616030d3531fc37a13bb44ea814d&quot;, trust_remote_code=True)</span></span><br><span class="line"><span class="comment">#model = AutoModel.from_pretrained(r&quot;E:\huggingface\models--THUDM--chatglm-6b\snapshots\a10da4c68b5d616030d3531fc37a13bb44ea814d&quot;, trust_remote_code=True).quantize(4).half().cuda()</span></span><br><span class="line"><span class="comment">#tokenizer = AutoTokenizer.from_pretrained(r&quot;E:\model\chatglm2-6b&quot;, trust_remote_code=True)</span></span><br><span class="line"><span class="comment">#model = AutoModel.from_pretrained(r&quot;E:\model\chatglm2-6b&quot;, trust_remote_code=True).quantize(4).half().cuda()</span></span><br></pre></td></tr></table></figure><p>现在就是线上模型了。但是按照他写的，我们现在实际上用的是CPU处理。还是使用上面的代码会报错，这里我们分两种情况：</p><h3 id="1、使用CPU进行推理："><a href="#1、使用CPU进行推理：" class="headerlink" title="1、使用CPU进行推理："></a>1、使用CPU进行推理：</h3><p>更改刚刚那段代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;THUDM/chatglm2-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;THUDM/chatglm2-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>).quantize(<span class="number">4</span>).half().<span class="built_in">float</span>()</span><br><span class="line"><span class="comment">#tokenizer = AutoTokenizer.from_pretrained(r&quot;E:\huggingface\models--THUDM--chatglm-6b\snapshots\a10da4c68b5d616030d3531fc37a13bb44ea814d&quot;, trust_remote_code=True)</span></span><br><span class="line"><span class="comment">#model = AutoModel.from_pretrained(r&quot;E:\huggingface\models--THUDM--chatglm-6b\snapshots\a10da4c68b5d616030d3531fc37a13bb44ea814d&quot;, trust_remote_code=True).quantize(4).half().cuda()</span></span><br><span class="line"><span class="comment">#tokenizer = AutoTokenizer.from_pretrained(r&quot;E:\model\chatglm2-6b&quot;, trust_remote_code=True)</span></span><br><span class="line"><span class="comment">#model = AutoModel.from_pretrained(r&quot;E:\model\chatglm2-6b&quot;, trust_remote_code=True).quantize(4).half().cuda()</span></span><br></pre></td></tr></table></figure><p>现在我们就可以在CPU上使用ChatGLM了。</p><h3 id="2、使用CUDA进行推理："><a href="#2、使用CUDA进行推理：" class="headerlink" title="2、使用CUDA进行推理："></a>2、使用CUDA进行推理：</h3><p>代码无需更改，但是我们需要更改torch的版本。现在是CPU版本，我们需要卸载并安装GPU版本。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall torch</span><br></pre></td></tr></table></figure><h4 id="2-1-你没有CUDA："><a href="#2-1-你没有CUDA：" class="headerlink" title="2.1 你没有CUDA："></a>2.1 你没有CUDA：</h4><p>没有安装CUDA的按照以下步骤下载并安装：<br>首先检查NVidia的显卡支持的CUDA版本：</p><ul><li>右键NVidia设置；</li><li>点击NVidia控制面板；</li><li>点击“帮助”-“系统信息”；</li><li>点击“组件”；</li><li>查看“3D 设置”-“NVCUDA64.DLL”-“产品名称”<br>想必电脑应该基本都是x64的CPU，如果还是x86的我也不知道怎么办，换电脑吧……<br>下载的CUDA版本不得低于产品名称里显示的版本。于是我下载了<a href="https://developer.download.nvidia.com/compute/cuda/12.2.2/local_installers/cuda_12.2.2_537.13_windows.exe">11.7的本地安装版</a><br>最新CUDA在<a href="https://developer.nvidia.com/cuda-downloads">这里</a>下载。<br>安装的时候，可以精简，如果没地方安装可以选择自定义，然后只选择CUDA，甚至还可以把CUDA的Document、Visual Studio支持也取消选择。<br>选择安装位置，点击安装。<br>接下来按照2.2走：</li></ul><h4 id="2-2-你有CUDA："><a href="#2-2-你有CUDA：" class="headerlink" title="2.2 你有CUDA："></a>2.2 你有CUDA：</h4><p>torch官网，找到Install PyTorch，按照实际情况选择：<br>我的情况：<br>系统：Windows<br>包安装器：Pip<br>语言：Python<br>计算平台：CUDA 11.7<br>那么就有：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu117</span><br></pre></td></tr></table></figure><p>记得以上命令在虚拟环境中执行。</p><p>然后我们可以这样验证：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>在python交互式终端中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><p>如果输出为True，那么我们就安装好了。我们正常使用就OK了。</p><h3 id="3、batch脚本一键启动"><a href="#3、batch脚本一键启动" class="headerlink" title="3、batch脚本一键启动"></a>3、batch脚本一键启动</h3><p>从<code>.\venv\Scripts\activate.bat</code>中，复制所有文本，在工作目录下新建<code>api.bat</code>，粘贴。<br>脚本：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...(这一段是你的activate.bat中的内容)</span><br><span class="line"><span class="comment">rem 更改标题</span></span><br><span class="line"><span class="built_in">title</span> ChatGLM-<span class="number">6</span>B WebUI API</span><br><span class="line"><span class="comment">rem 启动GLM层API</span></span><br><span class="line">python .\api.py</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><p>接下来是交互层API：</p><h2 id="0x3-搭建交互层API"><a href="#0x3-搭建交互层API" class="headerlink" title="0x3 搭建交互层API"></a>0x3 搭建交互层API</h2><p>这部分其实很简单，只需要更改一下他的插件里面的浏览器内核的配置就可以了：</p><ul><li>打开<code>.\plugins\web.py</code></li><li>更换所有的不在字符串里的<code>Chrome</code>为<code>Edge</code>，为的是使所有Chrome配置更改为Edge配置</li><li>保存<br>就搞定了。</li></ul><p>一键启动基本一样：<br>从<code>.\venv\Scripts\activate.bat</code>中，复制所有文本，在工作目录下新建<code>front_end.bat</code>，粘贴。<br>脚本：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...(这一段是你的activate.bat中的内容)</span><br><span class="line"><span class="comment">rem 更改标题</span></span><br><span class="line"><span class="built_in">title</span> ChatGLM-<span class="number">6</span>B WebUI front end</span><br><span class="line"><span class="comment">rem 启动交互层API</span></span><br><span class="line">python .\front_end.py</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><h2 id="0x4-搭建前端"><a href="#0x4-搭建前端" class="headerlink" title="0x4 搭建前端"></a>0x4 搭建前端</h2><p>有两种前端，一个是在项目主分支里写好的，已经被我们下载下来的前端，还有一种是另一根类Open AI式的前端。我会分开讲：</p><h3 id="1-使用已下载的前端"><a href="#1-使用已下载的前端" class="headerlink" title="1. 使用已下载的前端"></a>1. 使用已下载的前端</h3><p>一键启动就行：<br>从<code>.\venv\Scripts\activate.bat</code>中，复制所有文本，在工作目录下新建<code>web.bat</code>，粘贴。<br>脚本：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...(这一段是你的activate.bat中的内容)</span><br><span class="line"><span class="comment">rem 更改标题</span></span><br><span class="line"><span class="built_in">title</span> ChatGLM-<span class="number">6</span>B gradio demo</span><br><span class="line"><span class="comment">rem 启动GLM层API</span></span><br><span class="line">python .\gradio_demo.py</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><h3 id="2-使用类Open-AI的前端"><a href="#2-使用类Open-AI的前端" class="headerlink" title="2. 使用类Open AI的前端"></a>2. 使用类Open AI的前端</h3><p>从<a href="https://github.com/LemonQu-GIT/ChatGLM-6B-Engineering/archive/refs/heads/WebUI.zip">这里</a>下载，并解压缩到一个文件夹内，我个人习惯丢到工作目录下的新文件夹：<code>.\WebUI</code><br>解压缩之后，<a href="https://nodejs.org/download/release/v14.21.3/node-v14.21.3-x64.msi">下载</a>并安装node.js 14.21.3。<br>切换到WebUI工作目录并运行以下指令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>等安装完毕之后，打开<code>src\App.vue</code>，并修改：</p><ul><li>把所有的<code>process.env.VUE_APP_API</code>替换为<code>&quot;http://127.0.0.1:8003&quot;</code></li><li>保存<br>然后在创建一个<code>web.bat</code>，输入以下内容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rem 替换D:\your\path\to\webui为你的WebUI工作路径</span><br><span class="line">cd /D D:\your\path\to\webui</span><br><span class="line">title ChatGLM-6B Web UI</span><br><span class="line">npm run dev</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x5-修补"><a href="#0x5-修补" class="headerlink" title="0x5 修补"></a>0x5 修补</h2><ul><li><p>该插件使用markmap绘制思维导图<br>所以如果启用了markmap，你需要执行这个：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install markmap markmap-cli -g</span><br></pre></td></tr></table></figure></li><li><p>类Open AI前端的左侧标题有对于该主题的概括，但是概括的时候输入并没有被赋值，所以在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">chat</span>(<span class="params">prompt: <span class="built_in">str</span></span>):</span><br></pre></td></tr></table></figure><p>这一句后面添加一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chat_prompt = prompt <span class="comment"># This is temp fix. </span></span><br></pre></td></tr></table></figure><p>关于这一点我已经提交了issue，就看作者怎么处理这个了。</p></li></ul><hr><p>2023-09-03编辑：该bug已经修补了：<br><a href="https://github.com/LemonQu-GIT/ChatGLM-6B-Engineering/pull/31">A temp fix for sidebar title. 对于侧边栏标题的临时性修复。 by rong-xiaoli · Pull Request #31</a></p><ul><li>使用网络插件的时候，可能是因为某些bug，无法返回查询内容（可能连请求都发不出去），已经提交Issue：<a href="https://github.com/LemonQu-GIT/ChatGLM-6B-Engineering/issues/32">无法使用网络搜索 · Issue #32</a><br>我的解决方案是从Chrome切换至Edge，也就是把除了UA部分的Chrome全部改成Edge（或者说把所有Chrome的实现改为Edge）</li></ul><h2 id="0x6-最后需要注意的点"><a href="#0x6-最后需要注意的点" class="headerlink" title="0x6 最后需要注意的点"></a>0x6 最后需要注意的点</h2><ul><li>需要先启动GLM层API，启动完成后再启动交互层API；前端随时可以启动；</li><li>本篇所有的目录请根据实际情况核实一遍，不要直接<code>Ctrl+C</code>，<code>Ctrl+V</code>就不管了；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> LLM </tag>
            
            <tag> Python </tag>
            
            <tag> ChatGLM2-6B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电赛</title>
      <link href="/2023/08/04/%E7%94%B5%E8%B5%9B/"/>
      <url>/2023/08/04/%E7%94%B5%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>我们组选了个B题，同轴电缆长度与终端负载检测<br>上午还真没啥事，8点等题，上午买买器材，吃个午饭</p><p>同轴电缆长度测定原理：</p><blockquote><p>向同轴电缆发一道脉冲，由于一端开路，同轴电缆会反弹一道脉冲，这就意味着在同轴线一端测量波形，我们能得到两个波形：一个是发射波，一个是反弹波。</p></blockquote><p>GitHub上捞了个<a href="https://github.com/hugen79/NanoVNA-H">代码</a>，但是ChibiOS&#x2F;os&#x2F;hal&#x2F;ports&#x2F;STM32&#x2F;STM32F0xx&#x2F;hal_lld.c报错，换成<a href="https://github.com/DiSlord/NanoVNA-D">另一个</a>就搞定了（第二个现在还在更新，而且两个差别其实不是特别大，我们就可以比较方便地套用了）</p><p>主要是仪器还没到，不能刷固件确认。其实只要固件有了，基本都没什么太大问题，然后就是写论文了。<br>我们也是有能干起来的活的，比如测量的UI，不知道我能不能帮的上忙。（我C稀碎，而且python也是完全不会）</p><p>睡觉了，等第二天器材到了就开始忙了。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>快递早上就到了，接下来就是用micropython对NanoVNA的操作了。</p><p>之前没搞过micropython，踩了一些坑，跟着<a href="https://zhuanlan.zhihu.com/p/366411699">这篇文章</a>走了一遍，就能上了。<br>首先是环境，安装所需的requirements，然后看到有个模块叫machine<br>这个模块是micropython生成的，所以应该这么搞：<br>进入虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./venv/bin/activate</span><br></pre></td></tr></table></figure><p>Windows：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./venv/scripts/activate.bat</span><br></pre></td></tr></table></figure><p>之后（使用阿里云的镜像加速）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install micropy-cli esptool -i https://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure><p>擦除ESP32S3的固件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --chip esp32s3 --port /dev/yourDevice erase_flash</span><br></pre></td></tr></table></figure><p>将micropython的固件刷上ESP32：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --chip esp32s3 --port /dev/youtDevice write_flash -z 0 /path/to/BIN_FILE.bin</span><br></pre></td></tr></table></figure><p>串口连接ESP32S3，波特率115200，就可以了。</p><p>第一天的时候其实是这样的：打算使用官方的开源代码进行逆向，获取数据。今天找到了这个：<br>有这个软件：<a href="https://github.com/NanoVNA-Saver/nanovna-saver">NanoVNA-Saver</a>，是在Windows、Linux和MacOS上用于提取NanoVNA的数据的，也就是说NanoVNA-H使用串口进行调试，那么就可以通过串口指令提取数据：</p><blockquote><p>A multiplatform tool to save Touchstone files from the NanoVNA, sweep frequency spans in segments to gain more than 101 data points, and generally display and analyze the resulting data.</p></blockquote><blockquote><p>This software connects to a NanoVNA and extracts the data for display on a computer and allows saving the sweep data to Touchstone files.</p></blockquote><p>接下来就是串口截取数据了。Windows下可以使用<a href="http://www.ceiwei.com/mt/">CommMonitor</a>进行监视，Linux一开始用的是这个<a href="https://github.com/chipkin/Linux-HighSpeedSerialMonitor/">“HighSpeedSerialMonitor”</a>，但是用这个的话会报错闪退，ERROR - too many retries。我猜估计是占用问题，Windows下那个CommMonitor就没有问题。<br>搜到stackexchange.com貌似有个<a href="https://unix.stackexchange.com/questions/12359/how-can-i-monitor-serial-port-traffic">类似问题的帖子</a>，提到：</p><blockquote><p><a href="https://www.google.com/search?q=socat+serial+port+pty+tee+debug">Googling</a> “socat serial port pty tee debug” will point you to several “standard procedure” examples, one being:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socat  /dev/ttyS0,raw,<span class="built_in">echo</span>=0  \</span><br><span class="line">SYSTEM:<span class="string">&#x27;tee in.txt | socat - &quot;PTY,link=/tmp/ttyV0,raw,echo=0,waitslave&quot; | tee out.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>貌似没问题，时间来不及了，没时间验证，明天再说。<br>明天要验证socat端口转发，两个佬晚上通宵搞定软件和硬件，明天写完论文就搞定了。</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><blockquote><p>nanovna.py line 260 to line 270: </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tdr</span>(<span class="params">self, x</span>):</span><br><span class="line">pl.grid(<span class="literal">True</span>)</span><br><span class="line">window = np.blackman(<span class="built_in">len</span>(x))</span><br><span class="line">NFFT = <span class="number">256</span></span><br><span class="line">td = np.<span class="built_in">abs</span>(np.fft.ifft(window * x, NFFT))</span><br><span class="line">time = <span class="number">1</span> / (self.frequencies[<span class="number">1</span>] - self.frequencies[<span class="number">0</span>])</span><br><span class="line">t_axis = np.linspace(<span class="number">0</span>, time, NFFT)</span><br><span class="line">pl.plot(t_axis, td)</span><br><span class="line">pl.xlim(<span class="number">0</span>, time)</span><br><span class="line">pl.xlabel(<span class="string">&quot;time (s)&quot;</span>)</span><br><span class="line">pl.ylabel(<span class="string">&quot;magnitude&quot;</span>)</span><br></pre></td></tr></table></figure><p>问题是Micropython没有numpy，还有一个方案是捞个树莓派用，但是我觉得很臃肿，试着手搓一下Blackman，ittf和linspace，剩下的方案执行交给佬们。<br>linespace: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linspace</span>(<span class="params">start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>, axis=<span class="number">0</span></span>):</span><br><span class="line">out = [ <span class="built_in">float</span>(start) ] <span class="comment">#try to init output.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> endpoint:</span><br><span class="line">delta = <span class="built_in">float</span>((stop - start) / (num))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">delta = <span class="built_in">float</span>((stop - start) / (num - <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,num - <span class="number">1</span>):</span><br><span class="line">out.append(<span class="built_in">float</span>(out[i] + delta)) <span class="comment"># For each step, add the delta.</span></span><br><span class="line"><span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linspaceTest</span>():</span><br><span class="line"><span class="comment"># Test 1:</span></span><br><span class="line">result = libNumpy.linspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Should be: [2. , 2.25, 2.5 , 2.75, 3. ]&quot;</span>)</span><br><span class="line"><span class="comment"># Test 2:</span></span><br><span class="line">result = libNumpy.linspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">5</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Should be: [2. , 2.2, 2.4, 2.6, 2.8]&quot;</span>)</span><br></pre></td></tr></table></figure><p>强制转换的时候精度丢了，要改。</p><p>佬们做完树莓派的硬件适配了，可以不用管了，等会儿直接上树莓派就行了。</p><p>摸了一下午鱼，佬们把python写完了，捞了份源码下来。</p><blockquote><p>CR.py<br>main.py<br>nanovna.py<br>TDR.py<br>utils (dir)<br>├── Formatting.py<br>├── RFTools.py<br>└── SITools.py</p></blockquote><p>依赖安装貌似还是有点问题，总之先这么装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install luma</span><br><span class="line">pip install luma.core</span><br><span class="line">pip install luma.oled</span><br></pre></td></tr></table></figure><p>main.py为入口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">GPIO_init() <span class="comment"># init GPIO on rasp</span></span><br><span class="line">_cr() <span class="comment"># draw screen</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> GPIO.<span class="built_in">input</span>(<span class="number">4</span>):</span><br><span class="line">_cr() <span class="comment"># almost the same as _tdr()</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> GPIO.<span class="built_in">input</span>(<span class="number">17</span>):</span><br><span class="line">_tdr()</span><br></pre></td></tr></table></figure><p>首先初始化GPIO：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GPIO_init</span>():</span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br><span class="line">GPIO.setup(<span class="number">4</span>, GPIO.IN, pull_up_down=GPIO.PUD_UP)</span><br><span class="line">GPIO.setup(<span class="number">17</span>, GPIO.IN, pull_up_down=GPIO.PUD_UP)</span><br></pre></td></tr></table></figure><p>第4，17针脚用于接出两个按钮，所以是<code>GPIO.IN</code>，具体定义见GPIO。</p><p>接下来准备屏幕：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_cr</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CR&quot;</span>)</span><br><span class="line">stats(oled, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Unknown&quot;</span>)</span><br><span class="line">length, terminal_category, terminal_parameter = cr(nv, <span class="number">97e-12</span>) <span class="comment"># read from vna</span></span><br><span class="line"><span class="comment">#stats(oled, 1, length, terminal_category, terminal_parameter)</span></span><br><span class="line">stats(oled, <span class="number">0</span>, length, terminal_category, terminal_parameter) <span class="comment"># render</span></span><br><span class="line"><span class="comment"># cr(nv, 97e-12)</span></span><br></pre></td></tr></table></figure><p><code>stats()</code>用于更新屏幕，画出屏幕上的东西，比如各种参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stats</span>(<span class="params">oled, Condition, length, terminal_category, terminal_parameter</span>): <span class="comment">#render func</span></span><br><span class="line">oled.clear() <span class="comment">#clear the screen</span></span><br><span class="line"><span class="keyword">with</span> canvas(oled) <span class="keyword">as</span> draw:</span><br><span class="line">draw.text((<span class="number">1</span>,<span class="number">10</span>), <span class="string">&quot;condition&quot;</span>, fill=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">draw.text((<span class="number">1</span>,<span class="number">20</span>), <span class="string">&quot;length&quot;</span>, fill=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">draw.text((<span class="number">1</span>,<span class="number">30</span>), <span class="string">&quot;Load_Type&quot;</span>, fill=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">draw.text((<span class="number">1</span>,<span class="number">40</span>), <span class="string">&quot;Load_Para&quot;</span>, fill=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">draw.text((<span class="number">80</span>,<span class="number">10</span>), <span class="built_in">str</span>(Piget_condition(Condition)), fill=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">draw.text((<span class="number">50</span>,<span class="number">20</span>), <span class="string">f&quot;<span class="subst">&#123;(length*<span class="number">100</span>):<span class="number">.2</span>f&#125;</span> cm&quot;</span>, fill=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">draw.text((<span class="number">60</span>,<span class="number">30</span>), <span class="built_in">str</span>(Piget_terminal_category(terminal_category)[<span class="number">0</span>]), fill=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">draw.text((<span class="number">60</span>,<span class="number">40</span>), <span class="built_in">str</span>(terminal_parameter), fill=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">draw.text((<span class="number">80</span>,<span class="number">40</span>), <span class="built_in">str</span>(Piget_terminal_category(terminal_category)[<span class="number">1</span>]), fill=<span class="string">&quot;white&quot;</span>)</span><br></pre></td></tr></table></figure><p>还挺显而易见的。</p><p><code>Piget_terminal_category()</code>用于返回获取终端负载的类型的状态和单位，有开路，容性负载，和电阻：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Piget_terminal_category</span>(<span class="params">terminal_category</span>): <span class="comment"># terminal type</span></span><br><span class="line">    <span class="keyword">if</span> terminal_category ==<span class="number">0</span> :</span><br><span class="line">        Show_terminal_category = [<span class="string">&quot;open&quot;</span>,<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="keyword">elif</span> terminal_category ==<span class="number">1</span>:</span><br><span class="line">        Show_terminal_category = [<span class="string">&quot;C&quot;</span>,<span class="string">&quot;pF&quot;</span>]</span><br><span class="line">    <span class="keyword">elif</span> terminal_category ==<span class="number">2</span>:</span><br><span class="line">        Show_terminal_category = [<span class="string">&quot;R&quot;</span>,<span class="string">&quot;Ohm&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> Show_terminal_category</span><br></pre></td></tr></table></figure><p><code>Piget_condition()</code>用来获取树莓派的状态的文本，0是正在等待，1是正在测量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Piget_condition</span>(<span class="params">Condition</span>): <span class="comment"># current pi condition</span></span><br><span class="line">    <span class="keyword">if</span> Condition == <span class="number">1</span>:</span><br><span class="line">        Show_Condition = <span class="string">&quot;TESTING&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> Condition ==<span class="number">0</span>:</span><br><span class="line">        Show_Condition = <span class="string">&quot;HOLD&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Show_Condition</span><br></pre></td></tr></table></figure><p><code>_cr()</code>是用来提取从vna获取的数据的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_cr</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CR&quot;</span>)</span><br><span class="line">    stats(oled, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Unknown&quot;</span>)</span><br><span class="line">    length, terminal_category, terminal_parameter = cr(nv, <span class="number">97e-12</span>) <span class="comment"># read from vna</span></span><br><span class="line">    <span class="comment">#stats(oled, 1, length, terminal_category, terminal_parameter)</span></span><br><span class="line">    stats(oled, <span class="number">0</span>, length, terminal_category, terminal_parameter) <span class="comment"># render</span></span><br><span class="line">    <span class="comment"># cr(nv, 97e-12)</span></span><br></pre></td></tr></table></figure><p><code>_tdr()</code>也差不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_tdr</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;TDR&quot;</span>)</span><br><span class="line">    stats(oled, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Unknown&quot;</span>)</span><br><span class="line">    length, terminal_category, terminal_parameter = cr(nv, <span class="number">97e-12</span>) <span class="comment">#read from vna</span></span><br><span class="line">    <span class="comment">#stats(oled, 1, length, terminal_category, terminal_parameter)</span></span><br><span class="line">    stats(oled, <span class="number">0</span>, length, terminal_category, terminal_parameter) <span class="comment"># render</span></span><br></pre></td></tr></table></figure><p><code>cr()</code>用于从vna生数据做转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cr</span>(<span class="params">nv, offset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    nv: NanoVNA对象；</span></span><br><span class="line"><span class="string">    offset： 每米线电容大小（单位：F)， 1F = 1e12pF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cable_len, s11 = tdr(nv, <span class="number">50000</span>, <span class="number">200000000</span>) <span class="comment"># 200 MHz     ：线材够长</span></span><br><span class="line">    cable_len, s11 = tdr(nv, <span class="number">50000</span>, <span class="number">200000000</span>)</span><br><span class="line">    <span class="built_in">print</span>(cable_len)</span><br><span class="line">    <span class="keyword">if</span> cable_len &lt;= <span class="number">2.5</span>:</span><br><span class="line">        cable_len, s11 = tdr(nv, <span class="number">50000</span>, <span class="number">1500000000</span>) <span class="comment"># 1.5 GHz：线材小于2.5米</span></span><br><span class="line">        cable_len, s11 = tdr(nv, <span class="number">50000</span>, <span class="number">1500000000</span>)</span><br><span class="line">        <span class="built_in">print</span>(cable_len)</span><br><span class="line">    <span class="keyword">elif</span> cable_len &lt;= <span class="number">5</span>:</span><br><span class="line">        cable_len, s11 = tdr(nv, <span class="number">50000</span>, <span class="number">750000000</span>) <span class="comment"># 750 MHz ：线材小于5米</span></span><br><span class="line">        cable_len, s11 = tdr(nv, <span class="number">50000</span>, <span class="number">750000000</span>)</span><br><span class="line">        <span class="built_in">print</span>(cable_len)</span><br><span class="line">    imp = RFTools.gamma_to_impedance(<span class="built_in">complex</span>(s11[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], s11[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>])) <span class="comment"># 这是阻抗</span></span><br><span class="line">    imp_p = RFTools.serial_to_parallel(imp)</span><br><span class="line">    capacitance = RFTools.impedance_to_capacitance(imp, <span class="number">500000</span>)</span><br><span class="line">    resistance = imp_p.real <span class="comment"># 获取电阻</span></span><br><span class="line">    <span class="keyword">if</span> capacitance - (offset * cable_len) &gt;= <span class="number">90e-12</span>:</span><br><span class="line">        cap_str = format_capacitance(</span><br><span class="line">            <span class="comment"># 500000表示500kHz</span></span><br><span class="line">            RFTools.impedance_to_capacitance(imp, <span class="number">500000</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;类型：电容  电容值：<span class="subst">&#123;cap_str&#125;</span> 线长：<span class="subst">&#123;cable_len&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> cable_len, <span class="number">1</span>, cap_str</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt; resistance &lt;= <span class="number">60</span>:</span><br><span class="line">        resistance_str = format_resistance(imp_p.real)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;类型：电阻 电阻值：<span class="subst">&#123;resistance_str&#125;</span> 线长：<span class="subst">&#123;cable_len&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> cable_len, <span class="number">2</span>, resistance_str</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ((capacitance - (offset * cable_len) &gt;= <span class="number">90e-12</span>) <span class="keyword">or</span> (<span class="number">0</span> &lt; resistance &lt;= <span class="number">60</span>)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;开路 线长：<span class="subst">&#123;cable_len&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> cable_len, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(capacitance)</span><br><span class="line">    <span class="built_in">print</span>(resistance)</span><br><span class="line">    cap_str = format_capacitance(</span><br><span class="line">        <span class="comment"># 500000表示500kHz</span></span><br><span class="line">        RFTools.impedance_to_capacitance(imp, <span class="number">500000</span>)</span><br><span class="line">    )</span><br><span class="line">    resistance_str = format_resistance(imp_p.real)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;电容值为：<span class="subst">&#123;cap_str&#125;</span> 电阻值为：<span class="subst">&#123;resistance_str&#125;</span> 电缆长度为：<span class="subst">&#123;cable_len&#125;</span> m&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>tdr()</code>用于获取vna生数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tdr</span>(<span class="params">nv, start, end</span>):</span><br><span class="line">    nv.fetch_frequencies()</span><br><span class="line">    nv.fetch_frequencies()</span><br><span class="line">    s11 = nv.new_scan(start, end)</span><br><span class="line">    <span class="comment"># print(s11[1][0])</span></span><br><span class="line">    t_axies = nv.tdr(s11[<span class="number">0</span>])</span><br><span class="line">    d_axies = t_axies[<span class="number">0</span>] * <span class="number">0.71</span> * speed_of_light</span><br><span class="line">    index_peak = np.argmax(t_axies[<span class="number">1</span>])</span><br><span class="line">    cable_len = d_axies[index_peak] / <span class="number">2</span></span><br><span class="line">    <span class="comment"># print(f&#x27;Cable length: &#123;cable_len&#125; m&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> cable_len, s11</span><br></pre></td></tr></table></figure><p><code>RFTools.py</code>是用来计算的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gamma_to_impedance</span>(<span class="params">gamma: <span class="built_in">complex</span>, ref_impedance: <span class="built_in">float</span> = <span class="number">50</span></span>) -&gt; <span class="built_in">complex</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate impedance from gamma&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> ((-gamma - <span class="number">1</span>) / (gamma - <span class="number">1</span>)) * ref_impedance</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">return</span> math.inf</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">impedance_to_capacitance</span>(<span class="params">z: <span class="built_in">complex</span>, freq: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate capacitive equivalent for reactance&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> freq == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -math.inf</span><br><span class="line">    <span class="keyword">return</span> math.inf <span class="keyword">if</span> z.imag == <span class="number">0</span> <span class="keyword">else</span> -(<span class="number">1</span> / (freq * <span class="number">2</span> * math.pi * z.imag))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">impedance_to_inductance</span>(<span class="params">z: <span class="built_in">complex</span>, freq: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate inductive equivalent for reactance&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> freq == <span class="number">0</span> <span class="keyword">else</span> z.imag * <span class="number">1</span> / (freq * <span class="number">2</span> * math.pi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serial_to_parallel</span>(<span class="params">z: <span class="built_in">complex</span></span>) -&gt; <span class="built_in">complex</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Convert serial impedance to parallel impedance equivalent&quot;&quot;&quot;</span></span><br><span class="line">    z_sq_sum = z.real**<span class="number">2</span> + z.imag**<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> z.real == <span class="number">0</span> <span class="keyword">and</span> z.imag == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">complex</span>(math.inf, math.inf)</span><br><span class="line">    <span class="keyword">if</span> z.imag == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">complex</span>(z_sq_sum / z.real, math.copysign(math.inf, z_sq_sum))</span><br><span class="line">    <span class="keyword">if</span> z.real == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">complex</span>(math.copysign(math.inf, z_sq_sum), z_sq_sum / z.imag)</span><br><span class="line">    returnrs <span class="built_in">complex</span>(z_sq_sum / z.real, z_sq_sum / z.imag)</span><br></pre></td></tr></table></figure><p><code>SITools.py</code>是用来写科学计数法的。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>上面这个代码分析算是半梦半醒之间写出来的，弄完已经第二天早上6点了。<br>睡到中午12点，佬们开始重构代码了，要我读一遍写个框图。</p><pre class="mermaid">graph TDGlobalCapacitance(线路阻抗)InitBox(初始化) --> OLEDRefresh(屏幕刷新)OLEDRefresh --> Length[测量线长] --> MesureLength[扫频并获取频点数据<br/>Gamma转负阻抗<br/><br/>串联阻抗转并联阻抗<br/>阻抗转容性负载] --> |存储| GlobalCapacitance(线路阻抗) --> OLEDRefresh1GlobalCapacitance1(线路阻抗) --> CalculateLoadOLEDRefresh --> Load[测量负载] --> MesureLoad[扫频并获取频点数据<br/>Gamma转负阻抗<br/>串联阻抗转并联阻抗<br/>阻抗转容性负载] --> CalculateLoad[计算负载] --> OLEDRefresh1(屏幕刷新)</pre><p>搞定，装箱，明天回家。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔和笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 电赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RongXiaoliBotv0.2.1</title>
      <link href="/2023/03/21/RongXiaoliBotv0-2-1/"/>
      <url>/2023/03/21/RongXiaoliBotv0-2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="容小狸bot-v0-2-1更新日志"><a href="#容小狸bot-v0-2-1更新日志" class="headerlink" title="容小狸bot v0.2.1更新日志"></a>容小狸bot v0.2.1更新日志</h1><hr><h2 id="工程中"><a href="#工程中" class="headerlink" title="工程中"></a>工程中</h2><ul><li><input disabled="" type="checkbox"> 梗图生成器（得先找到API）</li><li><input disabled="" type="checkbox"> osu!bot(插件名称OsuBot)</li><li><input disabled="" type="checkbox"> backend&#x2F;Network&#x2F;HttpGet 和 backend&#x2F;Network&#x2F;HttpsGet 添加headers支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RongXiaoliBot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇post</title>
      <link href="/2023/03/01/FirstPost/"/>
      <url>/2023/03/01/FirstPost/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>这个GitHub的个人主页可以说是存在已久，但是最近想捞出来一用，于是就搞了个博客。</p><p>随便记点东西，可能会把容小狸Bot的更新日志发上来，也可能记载一些奇奇怪怪的教程与心得吧。</p><p>着实希望未来可期。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
